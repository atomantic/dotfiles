#!/bin/bash

# Updated code-review function with --cli support
code-review() {
	local cli_tool="q"
	local mr_input=""

	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--cli)
				if [[ -n "$2" && "$2" != --* ]]; then
					cli_tool="$2"
					shift 2
				else
					echo "Error: --cli requires a value (q or claude)"
					return 1
				fi
				;;
			*)
				if [[ -z "$mr_input" ]]; then
					mr_input="$1"
				fi
				shift
				;;
		esac
	done

	if [ -z "$mr_input" ]; then
		echo "Usage: code-review [--cli q|claude] <mr_number> or code-review [--cli q|claude] <merge_url>"
		return 1
	fi

	local mr_number=""

	echo "ðŸ” Starting code review for: $mr_input (using $cli_tool CLI)"

	# Check if we're already in a git repository and MR input is just a number
	local current_repo_path=""
	local skip_setup=false

	if [[ "$mr_input" =~ ^[0-9]+$ ]] && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		# We're in a git repo and MR input is just a number - use current directory
		current_repo_path="$(pwd)"
		skip_setup=true
		echo "ðŸ“‚ Using current repository: $current_repo_path"
	fi

	# Ask user if they want to set up repo locally (only for URLs and in interactive mode)
	local setup_locally="N"
	if [[ "$skip_setup" == false ]]; then
		if [[ -t 0 && -t 1 ]]; then
			echo -n "Set up repository locally for review? (y/N): "
			read setup_locally
		else
			echo "Running in non-interactive mode - performing remote review only"
		fi
	else
		setup_locally="Y"  # Force local setup since we're already in the repo
	fi

	if [[ $setup_locally =~ ^[Yy]$ ]]; then
		local repo_path

		if [[ "$skip_setup" == true ]]; then
			# Use current directory since we're already in the right repo
			repo_path="$current_repo_path"
		else
			echo "ðŸ“ Setting up repository locally..."

			# Setup repository and get path
			repo_path=$(code-setup --cli "$cli_tool" "$mr_input" 2>/dev/null | tail -1)

			if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
				echo "âŒ Error: Could not determine repository path"
				return 1
			fi

			echo "ðŸ“‚ Switching to repository: $repo_path"
			cd "$repo_path" || return 1
		fi

		# Extract MR number
		if [[ "$mr_input" =~ ^https?:// ]]; then
			mr_number=$(echo "$mr_input" | sed -E 's|.*/-/merge_requests/([0-9]+).*|\1|')
		elif [[ "$mr_input" =~ ^[0-9]+$ ]]; then
			mr_number="$mr_input"
		else
			mr_number="$mr_input"
		fi

		# Checkout the MR branch for review
		if [[ -n "$mr_number" ]]; then
			echo "ðŸ”„ Checking out MR branch #$mr_number..."

			# Switch to main branch first to avoid checkout conflicts
			git checkout main 2>/dev/null || git checkout master 2>/dev/null || git checkout qa 2>/dev/null || true

			# Fetch all remote branches to ensure we have the latest
			git fetch origin

			# Try to find and checkout the MR branch using native git
			local branch_found=false

			# Check if branch exists locally first
			if git show-ref --verify --quiet "refs/heads/mr-$mr_number"; then
				git checkout "mr-$mr_number"
				branch_found=true
			# Check for common MR branch patterns
			elif git show-ref --verify --quiet "refs/remotes/origin/mr-$mr_number"; then
				git checkout -b "mr-$mr_number" "origin/mr-$mr_number"
				branch_found=true
			elif git show-ref --verify --quiet "refs/remotes/origin/feature/mr-$mr_number"; then
				git checkout -b "feature/mr-$mr_number" "origin/feature/mr-$mr_number"
				branch_found=true
			fi

			# Fallback to CLI tools if native git didn't work
			if [[ "$branch_found" == false ]]; then
				echo "ðŸ”„ Using CLI tool to checkout MR branch..."
				if command -v glab >/dev/null 2>&1; then
					glab mr checkout "$mr_number"
				elif command -v gh >/dev/null 2>&1; then
					gh pr checkout "$mr_number"
				fi
			fi

			echo "âœ… Branch checked out successfully"
		fi
	fi

	echo "ðŸ¤– Launching AI code review (this may take a moment)..."

	# Prepare the prompt
	local review_prompt
	if [[ -n "$CODE_REVIEW_PROMPT" ]]; then
		review_prompt="$CODE_REVIEW_PROMPT

Review this merge: $mr_input"
	else
		# Fallback basic prompt if variable not found
		review_prompt="You are an expert software engineer conducting a thorough code review. Use glab or gh CLI tools to analyze the changes and post review comments.

Review this merge: $mr_input"
	fi

	# Execute with the specified CLI tool
	if [[ "$cli_tool" == "claude" ]]; then
		claude --dangerously-skip-permissions -p "$review_prompt"
	else
		q chat --no-interactive --trust-all-tools "$review_prompt"
	fi
}

#########################################
# Utility Functions

# Create a new git repo with one README commit and CD into it
function gitnr() { mkdir $1; cd $1; git init; touch README; git add README; git commit -mFirst-commit;}

# Do a Matrix movie effect of falling characters
function matrix1() {
echo -e "\e[1;40m" ; clear ; while :; do echo $LINES $COLUMNS $(( $RANDOM % $COLUMNS)) $(( $RANDOM % 72 )) ;sleep 0.05; done|gawk '{ letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()"; c=$4; letter=substr(letters,c,1);a[$3]=0;for (x in a) {o=a[x];a[x]=a[x]+1; printf "\033[%s;%sH\033[2;32m%s",o,x,letter; printf "\033[%s;%sH\033[1;37m%s\033[0;0H",a[x],x,letter;if (a[x] >= $1) { a[x]=0; } }}'
}

function matrix2() {
echo -e "\e[1;40m" ; clear ; characters=$( jot -c 94 33 | tr -d '\n' ) ; while :; do echo $LINES $COLUMNS $(( $RANDOM % $COLUMNS)) $(( $RANDOM % 72 )) $characters ;sleep 0.05; done|gawk '{ letters=$5; c=$4; letter=substr(letters,c,1);a[$3]=0;for (x in a) {o=a[x];a[x]=a[x]+1; printf "\033[%s;%sH\033[2;32m%s",o,x,letter; printf "\033[%s;%sH\033[1;37m%s\033[0;0H",a[x],x,letter;if (a[x] >= $1) { a[x]=0; } }}'
}

# Use Mac OS Preview to open a man page in a more handsome format
function manp() {
  man -t $1 | open -f -a /Applications/Preview.app
}

# Show normally hidden system and dotfile types of files
# in Mac OS Finder
function showhiddenfiles() {
  defaults write com.apple.Finder AppleShowAllFiles YES
  osascript -e 'tell application "Finder" to quit'
  sleep 0.25
  osascript -e 'tell application "Finder" to activate'
}

# Hide (back to defaults) normally hidden system and dotfile types of files
# in Mac OS Finder
function hidehiddenfiles() {
  defaults write com.apple.Finder AppleShowAllFiles NO
  osascript -e 'tell application "Finder" to quit'
  sleep 0.25
  osascript -e 'tell application "Finder" to activate'
}

## hammer a service with curl for a given number of times
## usage: curlhammer $url
function curlhammer () {
  bot "about to hammer $1 with $2 curls â‡’";
  echo "curl -k -s -D - $1 -o /dev/null | grep 'HTTP/1.1' | sed 's/HTTP\/1.1 //'"
  for i in {1..$2}
  do
    curl -k -s -D - $1 -o /dev/null | grep 'HTTP/1.1' | sed 's/HTTP\/1.1 //'
  done
  bot "done"
}

## curlheader will return only a specific response header or all response headers for a given URL
## usage: curlheader $header $url
## usage: curlheader $url
function curlheader() {
  if [[ -z "$2" ]]; then
    echo "curl -k -s -D - $1 -o /dev/null"
    curl -k -s -D - $1 -o /dev/null:
  else
    echo "curl -k -s -D - $2 -o /dev/null | grep $1:"
    curl -k -s -D - $2 -o /dev/null | grep $1:
  fi
}

## get the timings for a curl to a URL
## usage: curltime $url
function curltime(){
  curl -w "   time_namelookup:  %{time_namelookup}\n\
      time_connect:  %{time_connect}\n\
   time_appconnect:  %{time_appconnect}\n\
  time_pretransfer:  %{time_pretransfer}\n\
     time_redirect:  %{time_redirect}\n\
time_starttransfer:  %{time_starttransfer}\n\
--------------------------\n\
        time_total:  %{time_total}\n" -o /dev/null -s "$1"
}

function fixperms(){
    find . \( -name "*.sh" -or -type d \) -exec chmod 755 {} \; && find . -type f ! -name "*.sh" -exec chmod 644 {} \;
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Generate Subresource Integrity hashes.
# 1st argument is the filename.
# 2nd argument, optional, is the hash algorithm
# (currently the allowed prefixes are sha256, sha384, and sha512)
# See http://www.w3.org/TR/SRI/ and
# https://developer.mozilla.org/docs/Web/Security/Subresource_Integrity
function sri() {
  if [ -z "${1}" ]; then
    echo "ERROR: No file specified.";
    return 1;
  fi;
  local algorithm="${2:-sha512}"
  if ! echo "${algorithm}" | egrep -q "^sha(256|384|512)$"; then
    echo "ERROR: hash algorithm must be sha256, sha384 or sha512.";
    return 1;
  fi;
  local filehash=$(openssl dgst "-${algorithm}" -binary "$1" | openssl base64 -A)
  if [ -z "${filehash}" ]; then
    return 1;
  fi;
  echo "${algorithm}-${filehash}";
}

## output directory/file tree, excluding ignorables
function tre(){
  tree -aC -I '.git|node_modules|bower_components|.DS_Store' --dirsfirst "$@"
}

function weather() {
  curl wttr.in/$1
}
function ipinfo(){
  curl ipinfo.io/$1
}

# fo [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
function fo() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

#########################################
# Ghostty Project Launcher
# Usage: proj <project-path> [theme]
# Themes: blue, green, purple, orange, red, cyan
# Example: proj ~/projects/my-api green
# Example: proj ~/projects/frontend purple
function proj() {
  local project_path="${1:-.}"
  local theme="${2:-blue}"
  local theme_dir="$HOME/Library/Application Support/com.mitchellh.ghostty/themes"
  local theme_file="$theme_dir/$theme.conf"

  # Resolve to absolute path
  if [[ "$project_path" == "." ]]; then
    project_path="$(pwd)"
  else
    project_path="$(cd "$project_path" 2>/dev/null && pwd)"
  fi

  if [[ -z "$project_path" || ! -d "$project_path" ]]; then
    echo "Error: Directory not found: $1"
    return 1
  fi

  if [[ ! -f "$theme_file" ]]; then
    echo "Available themes: blue, green, purple, orange, red, cyan"
    echo "Error: Theme not found: $theme"
    return 1
  fi

  local project_name=$(basename "$project_path")

  # Theme emoji mapping
  local emoji
  case "$theme" in
    blue)   emoji="ðŸ”µ" ;;
    green)  emoji="ðŸŸ¢" ;;
    purple) emoji="ðŸŸ£" ;;
    orange) emoji="ðŸŸ " ;;
    red)    emoji="ðŸ”´" ;;
    cyan)   emoji="ðŸ©µ" ;;
    *)      emoji="âšª" ;;
  esac

  local window_title="${emoji} ${project_name}"

  # Find ghostty binary
  local ghostty_bin
  if command -v ghostty &>/dev/null; then
    ghostty_bin="ghostty"
  elif [[ -x "/Applications/Ghostty.app/Contents/MacOS/ghostty" ]]; then
    ghostty_bin="/Applications/Ghostty.app/Contents/MacOS/ghostty"
  elif [[ -x "$HOME/Applications/Ghostty.app/Contents/MacOS/ghostty" ]]; then
    ghostty_bin="$HOME/Applications/Ghostty.app/Contents/MacOS/ghostty"
  elif [[ -x "$HOME/Documents/Ghostty.app/Contents/MacOS/ghostty" ]]; then
    ghostty_bin="$HOME/Documents/Ghostty.app/Contents/MacOS/ghostty"
  else
    echo "Error: Ghostty not found"
    return 1
  fi

  # Launch Ghostty with project-specific settings
  "$ghostty_bin" \
    --config-file="$theme_file" \
    --title="$window_title" \
    --working-directory="$project_path" &

  disown
  echo "Launched: $window_title"
}

# List available Ghostty themes
function proj-themes() {
  echo "Available Ghostty project themes:"
  echo "  blue   - Default/main projects"
  echo "  green  - Backend/API projects"
  echo "  purple - Frontend/UI projects"
  echo "  orange - DevOps/Infrastructure"
  echo "  red    - Production/Critical"
  echo "  cyan   - Data/Analytics"
  echo ""
  echo "Usage: proj <project-path> [theme]"
  echo "Example: proj ~/projects/my-api green"
}